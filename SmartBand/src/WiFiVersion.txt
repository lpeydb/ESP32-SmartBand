#include <Arduino.h>
#include <Adafruit_GFX.h> //OLED libraries
#include <Adafruit_SSD1306.h>
#include <Wire.h>
#include "MAX30105.h"  //MAX3010x library
#include "heartRate.h" //Heart rate calculating algorithm
#include "ESP32Servo.h"
#include "pic.h"
#include "ArduinoJson.h"
#include <WiFi.h>
#include <HTTPClient.h>
#include <NTPClient.h>
MAX30105 particleSensor;
//定义引脚
int Tonepin = 4;
int Ledpin = 23;
int Buttonpin1 = 5;
int Buttonpin2 = 19;
//声光报警用变数
bool Max30102WorkRight = 0;
//切换事件用变数
int EventSwitch = 1;
//計算心跳用變數
const byte RATE_SIZE = 10; //多少平均數量
byte rates[RATE_SIZE];	   //心跳陣列
byte rateSpot = 0;
long lastBeat = 0; // Time at which the last beat occurred
float beatsPerMinute;
int beatAvg;
//計算血氧用變數
double avered = 0;
double aveir = 0;
double sumirrms = 0;
double sumredrms = 0;
double SpO2 = 0;
double ESpO2 = 90.0; //初始值
double FSpO2 = 0.7;	 // filter factor for estimated SpO2
double frate = 0.95; // low pass filter for IR/red LED value to eliminate AC component
int i = 0;
int Num = 30;			  //取樣100次才計算1次
#define FINGER_ON 7000	  //紅外線最小量（判斷手指有沒有上）
#define MINIMUM_SPO2 90.0 //血氧最小量
//定时器中断用变数
int TimeCounter = 0;
int TimeRequire = 1;
hw_timer_t *timer = NULL;
// oled初始化
#define SCREEN_WIDTH 128												  // OLED寬度
#define SCREEN_HEIGHT 64												  // OLED高度
#define OLED_RESET -1													  // Reset pin
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET); // Declaring the display name (display)
//	WiFi的初始化和连接
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP);
// WiFi用变数
String UID = "477768935";
String followerUrl = "http://api.bilibili.com/x/relation/stat?vmid=" + UID; // 粉丝数
long follower = 0;															// 粉丝数
DynamicJsonDocument doc(1024);
int currentHour;
int currentMinute;
int weekDay;
int monthDay;
int currentMonth;
//连接WiFi
void WiFi_Connect()
{
	WiFi.begin("Mytest", "123456789");
	while (WiFi.status() != WL_CONNECTED)
	{ //这里是阻塞程序，直到连接成功
		delay(300);
		Serial.print(".");
		display.clearDisplay();
		display.setTextSize(2);
		display.setTextColor(WHITE);
		display.setCursor(0, 0);
		display.print("WiFiConnet Failure");
		display.display();
	}
}
//	获取粉丝数
void getBiliBiliFollowers()
{
	HTTPClient http;
	http.begin(followerUrl); // HTTP begin
	int httpCode = http.GET();

	if (httpCode > 0)
	{
		// httpCode will be negative on error
		Serial.printf("HTTP Get Code: %d\r\n", httpCode);

		if (httpCode == HTTP_CODE_OK) // 收到正确的内容
		{
			String resBuff = http.getString();

			//	输出示例：{"mid":123456789,"following":226,"whisper":0,"black":0,"follower":867}}
			Serial.println(resBuff);

			//	使用ArduinoJson_6.x版本，具体请移步：https://github.com/bblanchon/ArduinoJson
			deserializeJson(doc, resBuff); //开始使用Json解析
			follower = doc["data"]["follower"];
			Serial.printf("Follers: %ld \r\n", follower);
		}
	}
	else
	{
		Serial.printf("HTTP Get Error: %s\n", http.errorToString(httpCode).c_str());
	}

	http.end();
}
//显示粉丝数
void showBilibiliFollower()
{
	display.clearDisplay();
	display.drawBitmap(0, 0, bilibili, 64, 64, 1);
	display.setTextSize(2);
	display.setTextColor(WHITE);
	display.setCursor(84, 24);
	display.print(follower);
	display.display();
}
//获取时间
void getTime()
{
	timeClient.update();
	Serial.println(timeClient.getFormattedTime());
	unsigned long epochTime = timeClient.getEpochTime();
	Serial.print("Epoch Time: ");
	Serial.println(epochTime);
	//打印时间
	currentHour = timeClient.getHours();
	Serial.print("Hour: ");
	Serial.println(currentHour);
	currentMinute = timeClient.getMinutes();
	Serial.print("Minutes: ");
	Serial.println(currentMinute);
	weekDay = timeClient.getDay();
	Serial.print("Week Day: ");
	Serial.println(weekDay);
	//将epochTime换算成年月日
	struct tm *ptm = gmtime((time_t *)&epochTime);
	monthDay = ptm->tm_mday;
	Serial.print("Month day: ");
	Serial.println(monthDay);
	currentMonth = ptm->tm_mon + 1;
	Serial.print("Month: ");
	Serial.println(currentMonth);
	delay(100);
}
//显示时间
void showTime()
{
	display.clearDisplay();
	display.setTextSize(4);
	display.setTextColor(WHITE);
	display.setCursor(0, 0);
	if (currentHour <= 10)
	{
		display.print("0");
	}
	display.print(currentHour);
	switch (i)
	{
	case 1:
		display.print(":");
		i++;
		break;

	default:
		display.print(" ");
		i = 1;
		break;
	}
	if (currentMinute <= 10)
	{
		display.print("0");
	}
	display.println(currentMinute);
	display.setTextSize(2);
	switch (weekDay)
	{
	case 1:
		display.println("Monday");
		break;
	case 2:
		display.println("Tuesday");
		break;
	case 3:
		display.println("Wednesday");
		break;
	case 4:
		display.println("Thursday");
		break;
	case 5:
		display.println("Friday");
		break;
	case 6:
		display.println("Saturday");
		break;
	case 7:
		display.println("Sunday");
		break;
	default:
		display.println("Unknown");
		break;
	}
	display.print(currentMonth);
	display.print("/");
	display.println(monthDay);
	display.display();
	delay(500);
}
//定时器中断事件
void IRAM_ATTR TimerEvent()
{
	TimeCounter++;
	Serial.print("TimeCounter:");
	Serial.println(TimeCounter);
	Serial.print("TimeRequire:");
	Serial.println(TimeRequire);
}
//按键1中断事件
void Button1IntEvent()
{
	if (EventSwitch < 5)
	{
		EventSwitch++;
	}
	else
	{
		EventSwitch = 1;
	}
	Serial.print("EventSwitch=");
	Serial.println(EventSwitch);
}
//按键2中断事件
void Button2IntEvent()
{
	if (EventSwitch == 4)
	{
		TimeRequire++;
	}
}
//显示需求时间
void showRequireTime()
{
	display.clearDisplay();
	display.setTextSize(1.5);
	display.setTextColor(WHITE);
	display.setCursor(0, 0);
	display.print("RequireTime:");
	display.print(TimeRequire);
	display.display();
}
//喝水吃药提示
void RemainDrinkEat()
{
	Serial.println("REALYRemainDrinkEat");
	display.clearDisplay();
	display.drawBitmap(0, 0, DrinkWater, 64, 64, 1);
	display.drawBitmap(64, 0, Pills, 64, 64, 1);
	display.display();
	digitalWrite(Ledpin, 1);
	delay(4000);
	display.clearDisplay();
	display.display();
	digitalWrite(Ledpin, 0);
	TimeCounter = 0;
	TimeRequire = 1;
	timerAlarmDisable(timer); // close Timer
	EventSwitch = 1;
}
//显示时间差
void showTimedifference()
{
	display.clearDisplay();
	display.setTextSize(1.5);
	display.setTextColor(WHITE);
	display.setCursor(0, 0);
	display.print("Timedifference:");
	display.print(TimeRequire - TimeCounter);
	display.display();
	//喝水吃药提示
	if (TimeCounter >= TimeRequire)
	{
		Serial.println("RemainDrinkEat");
		RemainDrinkEat();
	}
}
//声光警报
void LedToneAlarm()
{
	for (i = 0; i < 5; i++)
	{
		tone(Tonepin, 440);
		digitalWrite(Ledpin, 1);
		delay(256);
		tone(Tonepin, 329);
		digitalWrite(Ledpin, 0);
		delay(256);
	}
	noTone(Tonepin); //停止聲音
	Max30102WorkRight = 0;
	//清除心跳數據
	for (byte rx = 0; rx < RATE_SIZE; rx++)
		rates[rx] = 0;
	beatAvg = 0;
	rateSpot = 0;
	lastBeat = 0;
	//清除血氧數據
	avered = 0;
	aveir = 0;
	sumirrms = 0;
	sumredrms = 0;
	SpO2 = 0;
	ESpO2 = 90.0;
}
//测心率血氧函数
void Max30102Measure()
{
	long irValue = particleSensor.getIR(); // Reading the IR value it will permit us to know if there's a finger on the sensor or not
	//是否有放手指
	if (irValue > FINGER_ON)
	{
		display.clearDisplay();								//清除螢幕
		display.drawBitmap(5, 5, logo2_bmp, 24, 21, WHITE); //顯示小的心跳圖示
		display.setTextSize(2);								//設定文字大小
		display.setTextColor(WHITE);						//文字顏色
		display.setCursor(42, 10);							//設定游標位置
		display.print(beatAvg);
		display.println(" BPM");						  //顯示心跳數值
		display.drawBitmap(0, 35, O2_bmp, 32, 32, WHITE); //顯示氧氣圖示
		display.setCursor(42, 40);						  //設定游標位置
		//顯示血氧數值
		if (beatAvg > 30)
			display.print(String(ESpO2) + "%");
		else
			display.print("---- %");
		display.display(); //顯示螢幕
		//是否有心跳
		if (checkForBeat(irValue) == true)
		{
			display.clearDisplay();								//清除螢幕
			display.drawBitmap(0, 0, logo3_bmp, 32, 32, WHITE); //顯示大的心跳圖示
			display.setTextSize(2);								//設定文字大小
			display.setTextColor(WHITE);						//文字顏色
			display.setCursor(42, 10);							//設定游標位置
			display.print(beatAvg);
			display.println(" BPM");						  //顯示心跳數值
			display.drawBitmap(0, 35, O2_bmp, 32, 32, WHITE); //顯示氧氣圖示
			display.setCursor(42, 40);						  //設定游標位置
			//顯示血氧數值
			if (beatAvg > 30)
				display.print(String(ESpO2) + "%");
			else
				display.print("---- %");
			display.display();	 //顯示螢幕
			tone(Tonepin, 1000); //發出聲音
			delay(10);
			noTone(Tonepin); //停止聲音
			Serial.print("beatAvg=");
			Serial.println(beatAvg);		  //將心跳顯示到序列
			long delta = millis() - lastBeat; //計算心跳差
			lastBeat = millis();
			beatsPerMinute = 60 / (delta / 1000.0); //計算平均心跳
			if (beatsPerMinute < 255 && beatsPerMinute > 20)
			{
				//心跳必須再20-255之間
				rates[rateSpot++] = (byte)beatsPerMinute; //儲存心跳數值陣列
				rateSpot %= RATE_SIZE;
				beatAvg = 0; //計算平均值
				for (byte x = 0; x < RATE_SIZE; x++)
					beatAvg += rates[x];
				beatAvg /= RATE_SIZE;
			}
		}
		//計算血氧
		uint32_t ir, red;
		double fred, fir;
		particleSensor.check(); // Check the sensor, read up to 3 samples
		if (particleSensor.available())
		{
			i++;
			red = particleSensor.getFIFOIR(); //讀取紅光
			ir = particleSensor.getFIFORed(); //讀取紅外線
			// Serial.println("red=" + String(red) + ",IR=" + String(ir) + ",i=" + String(i));
			fred = (double)red;									   //轉double
			fir = (double)ir;									   //轉double
			avered = avered * frate + (double)red * (1.0 - frate); // average red level by low pass filter
			aveir = aveir * frate + (double)ir * (1.0 - frate);	   // average IR level by low pass filter
			sumredrms += (fred - avered) * (fred - avered);		   // square sum of alternate component of red level
			sumirrms += (fir - aveir) * (fir - aveir);			   // square sum of alternate component of IR level
			if ((i % Num) == 0)
			{
				double R = (sqrt(sumredrms) / avered) / (sqrt(sumirrms) / aveir);
				SpO2 = -23.3 * (R - 0.4) + 100;
				ESpO2 = FSpO2 * ESpO2 + (1.0 - FSpO2) * SpO2; // low pass filter
				if (ESpO2 <= MINIMUM_SPO2)
					ESpO2 = MINIMUM_SPO2; // indicator for finger detached
				if (ESpO2 > 100)
					ESpO2 = 99.9;
				Serial.print("Oxygen % = ");
				Serial.println(ESpO2);
				sumredrms = 0.0;
				sumirrms = 0.0;
				SpO2 = 0;
				i = 0;
			}
			particleSensor.nextSample(); // We're finished with this sample so move to next sample
		}

		//超过限值声光报警
		if ((beatAvg > 50) && (ESpO2 > 96))
		{
			Max30102WorkRight = 1;
		}

		if (Max30102WorkRight == 1 && ((beatAvg > 80) || (ESpO2 < 95) || (beatAvg < 50)))
		{

			LedToneAlarm();
		}
	}
	else
	{
		Max30102WorkRight = 0;
		//清除心跳數據
		for (byte rx = 0; rx < RATE_SIZE; rx++)
			rates[rx] = 0;
		beatAvg = 0;
		rateSpot = 0;
		lastBeat = 0;
		//清除血氧數據
		avered = 0;
		aveir = 0;
		sumirrms = 0;
		sumredrms = 0;
		SpO2 = 0;
		ESpO2 = 90.0;
		//显示手指图片
		display.clearDisplay();
		display.drawBitmap(32, 0, finger, 64, 64, 1);
		display.display();
		noTone(Tonepin);
	}
}
void setup()
{
	display.begin(SSD1306_SWITCHCAPVCC, 0x3C); // Start the OLED display
	display.clearDisplay();
	display.display();
	Serial.begin(115200);
	delay(500);

	Serial.print("WiFiConnecting.. ");
	WiFi_Connect();
	timeClient.begin();
	timeClient.setTimeOffset(28800); // + 1区 偏移3600， +8区 ：3600×8 = 28800
	Serial.println("WiFi connected");
	Serial.println("IP address: ");
	Serial.println(WiFi.localIP());

	pinMode(Ledpin, OUTPUT);
	//按键中断
	pinMode(Buttonpin1, INPUT_PULLUP);
	attachInterrupt(Buttonpin1, Button1IntEvent, FALLING);
	pinMode(Buttonpin2, INPUT_PULLUP);
	attachInterrupt(Buttonpin2, Button2IntEvent, FALLING);

	if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) // Use default I2C port, 400kHz speed
	{
		Serial.println("找不到MAX30102");
		while (1)
			;
	}
	byte ledBrightness = 0xFF; //亮度Options: 0=Off to 255=50mA         0x7F
	byte sampleAverage = 4;	   // Options: 1, 2, 4, 8, 16, 32            4
	byte ledMode = 2;		   // Options: 1 = Red only(心跳), 2 = Red + IR(血氧)
	// Options: 1 = IR only, 2 = Red + IR on MH-ET LIVE MAX30102 board
	int sampleRate = 1600; // Options: 50, 100, 200, 400, 800, 1000, 1600, 3200         800
	int pulseWidth = 215;  // Options: 69, 118, 215, 411
	int adcRange = 16384;  // Options: 2048, 4096, 8192, 16384

	// Set up the wanted parameters
	particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); // Configure sensor with these settings
	particleSensor.enableDIETEMPRDY();
	particleSensor.setPulseAmplitudeRed(0x0A); // Turn Red LED to low to indicate sensor is running  0x0A
	particleSensor.setPulseAmplitudeGreen(0);  // Turn off Green LED

	Serial.begin(115200);
	//	函数名称：timerBegin()
	//	函数功能：Timer初始化，分别有三个参数
	//	函数输入：1. 定时器编号（0到3，对应全部4个硬件定时器）
	//			 2. 预分频器数值（ESP32计数器基频为80M，80分频单位是微秒）
	//			 3. 计数器向上（true）或向下（false）计数的标志
	//	函数返回：一个指向 hw_timer_t 结构类型的指针
	timer = timerBegin(0, 80, true);

	//	函数名称：timerAttachInterrupt()
	//	函数功能：绑定定时器的中断处理函数，分别有三个参数
	//	函数输入：1. 指向已初始化定时器的指针（本例子：timer）
	//			 2. 中断服务函数的函数指针
	//			 3. 表示中断触发类型是边沿（true）还是电平（false）的标志
	//	函数返回：无
	timerAttachInterrupt(timer, &TimerEvent, true);

	//	函数名称：timerAlarmWrite()
	//	函数功能：指定触发定时器中断的计数器值，分别有三个参数
	//	函数输入：1. 指向已初始化定时器的指针（本例子：timer）
	//			 2. 第二个参数是触发中断的计数器值（1000000 us -> 1s）
	//			 3. 定时器在产生中断时是否重新加载的标志
	//	函数返回：无
	timerAlarmWrite(timer, 1000000, true);
}

void loop()
{
	switch (EventSwitch)
	{
	case 1:
		Max30102Measure();
		break;
	case 2:
		getTime();
		showTime();
		break;
	case 3:
		getBiliBiliFollowers();
		showBilibiliFollower();
		break;
	case 4:
		showRequireTime();
		break;
	case 5:
		if (TimeRequire != 1)
		{
			timerAlarmEnable(timer);  //	使能定时器
		}
		showTimedifference();
		break;
	default:
		Max30102Measure();
		break;
	}
	delay(1);
}